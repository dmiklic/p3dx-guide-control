#!/usr/bin/env python


### Author: Jurica Papak

import sys
import rospy
import numpy as np
import tf
import copy
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from obstacle_detector.msg import Obstacles, CircleObstacle

# status of the guide controller:
# 0 - no actor available for guiding, finding actor
# 1 - locked on actor, guiding
guide_status = 0

# last known actor location
actor_loc_x = 0
actor_loc_y = 0

# tolerance of actor movement in a timestep
ACTOR_TOL = 0.2

# how far the robot will try to stay ahead of the actor
GUIDE_DISTANCE = 1
SIGMOID_FACTOR = np.log(99)/GUIDE_DISTANCE

# last known actor velocity
actor_vel_x = 0
actor_vel_y = 0

# last known robot location and heading
robot_loc_x = 0
robot_loc_y = 0
robot_angle = 0 # [-pi, pi]

# publisher for cmd_vel
cmd_vel_pub = None

# sigmoid defined around keeping the actor at the GUIDE_DISTANCE
def sigmoid(x):
    return 2 / (1 + np.exp(SIGMOID_FACTOR*(x-GUIDE_DISTANCE)))

def wrap_to_pi(angle):
    return (angle + np.pi) % (2 * np.pi) - np.pi

def correct_for_distance(original_vel, distance):
    factor = sigmoid(distance)
    if factor < 0.05:
        factor = 0
    original_vel.linear.x *= factor
    original_vel.angular.z *= factor

def correct_for_angle(original_vel, angle, robot_heading):
    pass

# for augmenting cmd_vel according to the actor-robot relation
def cmd_vel_callback(cmd_vel):
    global robot_loc_x, robot_loc_y, robot_angle, actor_loc_x, actor_loc_y
    dist_vector = np.array([robot_loc_x - actor_loc_x, robot_loc_y - actor_loc_y])
    # distance correction
    distance = np.linalg.norm(dist_vector)
    correct_for_distance(cmd_vel, distance)
    # angle correction
    angle = np.arctan2(dist_vector[1], dist_vector[0])
    wrapped_angle = wrap_to_pi(np.abs(robot_angle - angle))
    correct_for_angle(cmd_vel, wrapped_angle, robot_angle)

    cmd_vel_pub.publish(cmd_vel)

# for updating the robot position
def odom_callback(odom):
    global robot_loc_x, robot_loc_y, robot_angle
    pose = odom.pose.pose

    robot_loc_x = pose.position.x
    robot_loc_y = pose.position.y

    quaternion = (pose.orientation.x, pose.orientation.y, pose.orientation.z,
                  pose.orientation.w)
    euler = tf.transformations.euler_from_quaternion(quaternion)
    robot_angle = euler[2] # yaw angle used for robot heading

# for updating the actor position
def obstacle_callback(obstacles):
    global actor_loc_x, actor_loc_y, actor_vel_x, actor_vel_y, ACTOR_TOL
    for circle in obstacles.circles:
        x, y = circle.center.x, circle.center.y
        if np.abs(x - actor_loc_x) < ACTOR_TOL and \
           np.abs(y - actor_loc_y) < ACTOR_TOL:
            actor_loc_x, actor_loc_y = x, y
            actor_vel_x, actor_vel_y = circle.velocity.x, circle.velocity.y

# actor location inialization; uses closest actor behind the robot
def get_actor():
    global actor_loc_x, actor_loc_y, robot_loc_x, robot_loc_y, robot_angle
    try:
        best_candidate = None
        min_distance = 10000
        obstacles = rospy.wait_for_message('obstacles', Obstacles, timeout=2)
        for circle in obstacles.circles:
            dist_vector = np.array([robot_loc_x - circle.center.x, robot_loc_y - circle.center.y])
            angle = np.arctan2(dist_vector[1], dist_vector[0])
            wrapped_angle = wrap_to_pi(np.abs(robot_angle - angle))
            if np.abs(wrapped_angle) < 1:
                distance = np.linalg.norm(dist_vector)
                if distance < min_distance:
                    best_candidate = (circle.center.x, circle.center.y)
                    min_distance = distance

        if best_candidate == None:
            print ("[GUIDE_CONTROL]: No suitable actor found! Trying again...")
            return False
        else:
            actor_loc_x = best_candidate[0]
            actor_loc_y = best_candidate[1]
            print ("[GUIDE_CONTROL]: Actor at location (%3f,%3f) chosen." % (actor_loc_x, actor_loc_y))
            return True

    except rospy.ROSException:
        print ("[GUIDE_CONTROL]: Message couldn't be recieved in time. Check /obstacles topic.")
        return False


def get_robot():
    try:
        odom = rospy.wait_for_message('odom', Odometry, timeout=2)
        # use the odom_callback function for updating the globals
        odom_callback(odom)
    except rospy.ROSException:
        print ("[GUIDE_CONTROL]: Robot pose couldn't be retrieved in time.")


def main():
    global guide_status, actor_loc_x, actor_loc_y, robot_loc_x, robot_loc_y, robot_angle, cmd_vel_pub

    # initialize the node
    rospy.init_node('guide_control')
    mainloop_rate = rospy.Rate(1)

    # determine initial robot
    get_robot()

    # publisher/subscriber initialization
    cmd_vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size=2)
    rospy.Subscriber('cmd_vel_dwb', Twist, cmd_vel_callback, queue_size=1)
    rospy.Subscriber('odom', Odometry, odom_callback, queue_size=1)
    rospy.Subscriber('obstacles', Obstacles, obstacle_callback, queue_size=1)

    print ("[GUIDE_CONTROL]: Initialization successful.")
    while(1):
        if guide_status == 1:
            print(["[GUIDE_CONTROL]: actor tracked at (%f %f)" % (actor_loc_x, actor_loc_y)])
        elif guide_status == 0:
            if get_actor():
                guide_status = 1

        mainloop_rate.sleep()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
